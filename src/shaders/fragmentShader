#version 400 core

in vec2 pass_textureCords;
in vec3 surfaceNormal;
in vec3 toLightVetor[4];
in vec3 toCameraVetor;
in float visibility;

out vec4 outColour;

uniform sampler2D textureSampler;
uniform vec3 lightColour[4];

uniform float shineDamper;
uniform float reflectivity;
uniform vec3 skyColour;

uniform vec3 attenuation[4];

void main(void){
    vec3 unitNormal = normalize(surfaceNormal);
    vec3 unitTocamera = normalize(toCameraVetor);
    vec3 finalSpecular = vec3(0.0);
    vec3 diffuse = vec3(0.0);
    for(int i = 0; i < 4; i++){

        float distance = length(toLightVetor[i]);
        float attFactor = attenuation[i].x + attenuation[i].y * distance + attenuation[i].z * distance * distance;

        vec3 unitLight = normalize(toLightVetor[i]);
        vec3 lightDirection = -unitLight;
        vec3 reflecedLightDirection = reflect(lightDirection, unitNormal);

        float specularFactor = dot(reflecedLightDirection, unitTocamera);
        specularFactor = max(specularFactor, 0.0);
        float damperFactor = pow(specularFactor, shineDamper);
        finalSpecular = finalSpecular + (damperFactor * lightColour[i] * reflectivity)/attFactor;

        float nDotl = dot(unitNormal, unitLight);
        float brightness = max(nDotl, 0.0);
        diffuse = diffuse + (brightness * lightColour[i])/attFactor;
    }
    diffuse = max(diffuse, 0.2);
    vec4 textureColour = texture(textureSampler, pass_textureCords);
    if(textureColour.a < 0.5){
        discard;
    }

    outColour = vec4(diffuse, 1.0) * textureColour + vec4(finalSpecular, 1.0);
    outColour = mix(vec4(skyColour, 1.0), outColour, visibility);
}