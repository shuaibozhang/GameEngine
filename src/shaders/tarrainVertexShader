#version 400 core

in vec3 position;
in vec2 textureCoords;
in vec3 normals;

out vec2 pass_textureCords;
out vec3 surfaceNormal;
out vec3 toLightVetor[4];
out vec3 toCameraVetor;
out float visibility;

uniform mat4 transformMat;
uniform mat4 projectionMat;
uniform mat4 viewMat;
uniform vec3 lightPosition[4];

const float density = 0.003;
const float gradient = 1.0;

uniform vec4 plane;

float LinearizeDepth(float depth)
{
    float near = 0.1;
    float far = 10000.0;
    float z = depth * 2.0 - 1.0; // Back to NDC
    return (2.0 * near) / (far + near - z * (far - near));
}

float testz(vec4 pos)
{
    return pos.z * pos.z;
}

void main(void){
    vec4 worldPosition = transformMat * vec4(position, 1.0);

    gl_ClipDistance[0] = dot(worldPosition, plane);

    gl_Position = projectionMat * viewMat * worldPosition;
    pass_textureCords = textureCoords;

    surfaceNormal = (transformMat * vec4(normals, 0.0)).xyz;

    for(int i = 0; i < 4; i++){
        toLightVetor[i] = lightPosition[i] - worldPosition.xyz;
    }

    toCameraVetor = (inverse(viewMat) * vec4(0.0, 0.0, 0.0, 1.0)).xyz - worldPosition.xyz;

    float distance = length(toCameraVetor);
    visibility = exp(-pow((distance * density), gradient));
    visibility = clamp(visibility, 0.0, 1.0);
}