#version 400 core

in vec3 position;
in vec2 textureCoords;
in vec3 normals;

out vec2 pass_textureCords;
out vec3 surfaceNormal;
out vec3 toLightVetor;
out vec3 toCameraVetor;
out float visibility;

uniform mat4 transformMat;
uniform mat4 projectionMat;
uniform mat4 viewMat;
uniform vec3 lightPosition;
uniform float useFakeLighting;

uniform float numOfRows;
uniform vec2 offset;

const float density = 0.006;
const float gradient = 1.5;

float LinearizeDepth(float depth)
{
    float near = 0.1;
    float far = 1000.0;
    float z = depth * 2.0 - 1.0; // Back to NDC
    return (2.0 * near) / (far + near - z * (far - near));
}

void main(void){
    vec4 worldPosition = transformMat * vec4(position, 1.0);

    vec4 posToCam = viewMat * worldPosition;

    gl_Position = projectionMat * posToCam;
    //gl_Position.z = LinearizeDepth(gl_Position.z);

    pass_textureCords = textureCoords/numOfRows + offset;

    vec3 truenormals = normals;
    if(useFakeLighting > 0.5){
        truenormals = vec3(0.0,1.0,0.0);
    }

    surfaceNormal = (transformMat * vec4(truenormals, 0.0)).xyz;
    toLightVetor = lightPosition - worldPosition.xyz;

    toCameraVetor = (inverse(viewMat) * vec4(0.0, 0.0, 0.0, 1.0)).xyz - worldPosition.xyz;

    float distance = length(posToCam);
    visibility = exp(-pow((distance * density), gradient));
    visibility = clamp(visibility, 0.0, 1.0);
}